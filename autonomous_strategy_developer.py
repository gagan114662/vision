"""
Autonomous Strategy Development System

Following Anthropic's principles for writing tools for agents:
1. Give agents real tools that work
2. Design tools for agents, not humans
3. Make tools composable and specific
4. Emit detailed results that agents can parse
5. Handle errors gracefully with clear feedback

This system autonomously:
1. Generates market hypotheses using MCP servers
2. Develops trading strategies based on agent insights
3. Backtests strategies using real QuantConnect API
4. Iterates and improves based on results
"""
from __future__ import annotations

import asyncio
import json
import logging
import os
import time
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum

# Import our MCP servers and agents
from mcp.servers import ally_shell_server
from agents.implementations.fundamental_agent import FundamentalAgent
from agents.implementations.technical_agent import TechnicalAgent
from agents.implementations.sentiment_agent import SentimentAgent
from agents.implementations.quantitative_agent import QuantitativeAgent

# Import portfolio optimizers
from mcp.portfolio.hrp_optimizer import HRPOptimizer, HRPParameters
from mcp.portfolio.black_litterman import (
    BlackLittermanOptimizer, AgentView, ViewType, ConfidenceLevel
)

# Import compliance and monitoring
from mcp.compliance.mifid_ii import MiFIDComplianceManager, ClientCategory
from mcp.monitoring.production_monitor import ProductionMonitor

logger = logging.getLogger(__name__)


class HypothesisType(Enum):
    """Types of market hypotheses."""
    MEAN_REVERSION = "mean_reversion"
    MOMENTUM = "momentum"
    SEASONAL = "seasonal"
    ARBITRAGE = "arbitrage"
    FACTOR_EXPOSURE = "factor_exposure"
    REGIME_CHANGE = "regime_change"
    EARNINGS_MOMENTUM = "earnings_momentum"
    SENTIMENT_DIVERGENCE = "sentiment_divergence"


class StrategyStatus(Enum):
    """Strategy development status."""
    HYPOTHESIS_GENERATED = "hypothesis_generated"
    STRATEGY_DESIGNED = "strategy_designed"
    BACKTEST_QUEUED = "backtest_queued"
    BACKTEST_RUNNING = "backtest_running"
    BACKTEST_COMPLETED = "backtest_completed"
    STRATEGY_APPROVED = "strategy_approved"
    STRATEGY_REJECTED = "strategy_rejected"
    LIVE_DEPLOYED = "live_deployed"


@dataclass
class MarketHypothesis:
    """Market hypothesis generated by agents."""
    hypothesis_id: str
    type: HypothesisType
    description: str
    generating_agent: str
    confidence: float  # 0-1
    time_horizon_days: int
    target_assets: List[str]
    expected_return: float
    risk_factors: List[str]
    supporting_evidence: Dict[str, Any]
    generated_at: datetime
    rationale: str


@dataclass
class TradingStrategy:
    """Complete trading strategy definition."""
    strategy_id: str
    name: str
    hypothesis: MarketHypothesis
    algorithm_code: str
    parameters: Dict[str, Any]
    universe: List[str]
    benchmark: str
    start_date: str
    end_date: str
    initial_cash: float
    status: StrategyStatus
    backtest_results: Optional[Dict[str, Any]] = None
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


class HypothesisGenerator:
    """Generate market hypotheses using agent insights."""

    def __init__(self):
        self.fundamental_agent = FundamentalAgent("fundamental")
        self.technical_agent = TechnicalAgent("technical")
        self.sentiment_agent = SentimentAgent("sentiment")
        self.quantitative_agent = QuantitativeAgent("quantitative")

        self.generated_hypotheses: List[MarketHypothesis] = []

    async def generate_market_hypothesis(
        self,
        market_data: Dict[str, Any],
        focus_assets: List[str]
    ) -> List[MarketHypothesis]:
        """Generate hypotheses by polling all agents."""

        hypotheses = []

        # Get insights from each agent
        for asset in focus_assets[:5]:  # Limit to 5 assets for efficiency
            try:
                # Fundamental hypothesis
                fund_analysis = await self.fundamental_agent.analyze_stock(asset, market_data)
                if fund_analysis and fund_analysis.get('confidence', 0) > 0.6:
                    hypothesis = self._create_fundamental_hypothesis(asset, fund_analysis)
                    hypotheses.append(hypothesis)

                # Technical hypothesis
                tech_analysis = await self.technical_agent.analyze_stock(asset, market_data)
                if tech_analysis and tech_analysis.get('confidence', 0) > 0.6:
                    hypothesis = self._create_technical_hypothesis(asset, tech_analysis)
                    hypotheses.append(hypothesis)

                # Sentiment hypothesis
                sent_analysis = await self.sentiment_agent.analyze_market_sentiment(asset, market_data)
                if sent_analysis and sent_analysis.get('confidence', 0) > 0.6:
                    hypothesis = self._create_sentiment_hypothesis(asset, sent_analysis)
                    hypotheses.append(hypothesis)

                # Quantitative hypothesis
                quant_analysis = await self.quantitative_agent.analyze_factors(asset, market_data)
                if quant_analysis and quant_analysis.get('confidence', 0) > 0.6:
                    hypothesis = self._create_quantitative_hypothesis(asset, quant_analysis)
                    hypotheses.append(hypothesis)

                # Rate limit to avoid overwhelming APIs
                await asyncio.sleep(0.1)

            except Exception as e:
                logger.error(f"Failed to generate hypothesis for {asset}: {e}")

        # Cross-asset hypotheses
        if len(focus_assets) > 1:
            pair_hypothesis = await self._generate_pair_hypothesis(focus_assets[:2], market_data)
            if pair_hypothesis:
                hypotheses.append(pair_hypothesis)

        self.generated_hypotheses.extend(hypotheses)
        return hypotheses

    def _create_fundamental_hypothesis(
        self,
        asset: str,
        analysis: Dict[str, Any]
    ) -> MarketHypothesis:
        """Create hypothesis from fundamental analysis."""

        recommendation = analysis.get('recommendation', 'hold').lower()
        confidence = analysis.get('confidence', 0.5)

        if recommendation == 'buy':
            hypothesis_type = HypothesisType.EARNINGS_MOMENTUM
            expected_return = 0.15  # 15% expected return
        elif recommendation == 'sell':
            hypothesis_type = HypothesisType.MEAN_REVERSION
            expected_return = -0.10  # Expect decline
        else:
            hypothesis_type = HypothesisType.FACTOR_EXPOSURE
            expected_return = 0.05  # Market return

        return MarketHypothesis(
            hypothesis_id=f"fund_{asset}_{int(time.time())}",
            type=hypothesis_type,
            description=f"Fundamental analysis suggests {recommendation} for {asset}",
            generating_agent="fundamental",
            confidence=confidence,
            time_horizon_days=90,
            target_assets=[asset],
            expected_return=expected_return,
            risk_factors=["earnings_risk", "sector_rotation", "market_volatility"],
            supporting_evidence=analysis,
            generated_at=datetime.now(timezone.utc),
            rationale=analysis.get('reasoning', 'Fundamental analysis based')
        )

    def _create_technical_hypothesis(
        self,
        asset: str,
        analysis: Dict[str, Any]
    ) -> MarketHypothesis:
        """Create hypothesis from technical analysis."""

        recommendation = analysis.get('recommendation', 'hold').lower()
        confidence = analysis.get('confidence', 0.5)

        if recommendation == 'buy':
            hypothesis_type = HypothesisType.MOMENTUM
            expected_return = 0.08
        else:
            hypothesis_type = HypothesisType.MEAN_REVERSION
            expected_return = -0.05

        return MarketHypothesis(
            hypothesis_id=f"tech_{asset}_{int(time.time())}",
            type=hypothesis_type,
            description=f"Technical indicators suggest {recommendation} for {asset}",
            generating_agent="technical",
            confidence=confidence,
            time_horizon_days=30,
            target_assets=[asset],
            expected_return=expected_return,
            risk_factors=["momentum_reversal", "technical_breakdown"],
            supporting_evidence=analysis,
            generated_at=datetime.now(timezone.utc),
            rationale=analysis.get('reasoning', 'Technical analysis based')
        )

    def _create_sentiment_hypothesis(
        self,
        asset: str,
        analysis: Dict[str, Any]
    ) -> MarketHypothesis:
        """Create hypothesis from sentiment analysis."""

        recommendation = analysis.get('recommendation', 'hold').lower()
        confidence = analysis.get('confidence', 0.5)

        return MarketHypothesis(
            hypothesis_id=f"sent_{asset}_{int(time.time())}",
            type=HypothesisType.SENTIMENT_DIVERGENCE,
            description=f"Sentiment analysis suggests {recommendation} for {asset}",
            generating_agent="sentiment",
            confidence=confidence,
            time_horizon_days=14,
            target_assets=[asset],
            expected_return=0.03 if recommendation == 'buy' else -0.02,
            risk_factors=["sentiment_reversal", "news_events"],
            supporting_evidence=analysis,
            generated_at=datetime.now(timezone.utc),
            rationale=analysis.get('reasoning', 'Sentiment analysis based')
        )

    def _create_quantitative_hypothesis(
        self,
        asset: str,
        analysis: Dict[str, Any]
    ) -> MarketHypothesis:
        """Create hypothesis from quantitative analysis."""

        recommendation = analysis.get('recommendation', 'hold').lower()
        confidence = analysis.get('confidence', 0.5)

        return MarketHypothesis(
            hypothesis_id=f"quant_{asset}_{int(time.time())}",
            type=HypothesisType.FACTOR_EXPOSURE,
            description=f"Factor analysis suggests {recommendation} for {asset}",
            generating_agent="quantitative",
            confidence=confidence,
            time_horizon_days=60,
            target_assets=[asset],
            expected_return=0.06 if recommendation == 'buy' else -0.03,
            risk_factors=["factor_rotation", "model_risk"],
            supporting_evidence=analysis,
            generated_at=datetime.now(timezone.utc),
            rationale=analysis.get('reasoning', 'Quantitative factor analysis')
        )

    async def _generate_pair_hypothesis(
        self,
        asset_pair: List[str],
        market_data: Dict[str, Any]
    ) -> Optional[MarketHypothesis]:
        """Generate pairs trading hypothesis."""

        try:
            # Simple correlation-based pairs hypothesis
            asset_a, asset_b = asset_pair

            return MarketHypothesis(
                hypothesis_id=f"pair_{asset_a}_{asset_b}_{int(time.time())}",
                type=HypothesisType.ARBITRAGE,
                description=f"Pairs trading opportunity between {asset_a} and {asset_b}",
                generating_agent="quantitative",
                confidence=0.65,
                time_horizon_days=30,
                target_assets=asset_pair,
                expected_return=0.04,
                risk_factors=["correlation_breakdown", "execution_risk"],
                supporting_evidence={"correlation": 0.85, "spread_z_score": 2.1},
                generated_at=datetime.now(timezone.utc),
                rationale="Statistical arbitrage based on historical correlation"
            )
        except Exception as e:
            logger.error(f"Failed to generate pair hypothesis: {e}")
            return None


class StrategyCodeGenerator:
    """Generate QuantConnect algorithm code from hypotheses."""

    def generate_algorithm_code(self, hypothesis: MarketHypothesis) -> str:
        """Generate complete QuantConnect algorithm code."""

        strategy_name = f"{hypothesis.type.value.title()}Strategy"

        # Base algorithm template
        algorithm_code = f'''
from AlgorithmImports import *

class {strategy_name}(QCAlgorithm):
    """
    {hypothesis.description}

    Generated by Autonomous Strategy Developer
    Hypothesis ID: {hypothesis.hypothesis_id}
    Generated at: {hypothesis.generated_at.isoformat()}
    Confidence: {hypothesis.confidence:.2f}
    """

    def Initialize(self):
        # Set algorithm parameters
        self.SetStartDate({self._get_start_date()})
        self.SetEndDate({self._get_end_date()})
        self.SetCash(100000)

        # Add universe
{self._generate_universe_code(hypothesis.target_assets)}

        # Initialize indicators and variables
        self.positions = {{}}
        self.rebalance_time = None

        # Schedule rebalancing
        self.Schedule.On(
            self.DateRules.MonthBeginning("SPY"),
            self.TimeRules.AfterMarketOpen("SPY", 30),
            self.Rebalance
        )

    def OnData(self, data):
        """Handle incoming data."""
        pass

    def Rebalance(self):
        """Execute rebalancing logic based on hypothesis."""
{self._generate_strategy_logic(hypothesis)}

    def OnSecuritiesChanged(self, changes):
        """Handle universe changes."""
        for security in changes.RemovedSecurities:
            if security.Symbol in self.positions:
                self.Liquidate(security.Symbol)
                del self.positions[security.Symbol]

{self._generate_helper_methods(hypothesis)}
'''
        return algorithm_code

    def _get_start_date(self) -> str:
        """Get start date for backtest."""
        return "2023, 1, 1"

    def _get_end_date(self) -> str:
        """Get end date for backtest."""
        return "2024, 1, 1"

    def _generate_universe_code(self, assets: List[str]) -> str:
        """Generate universe selection code."""
        universe_code = ""
        for asset in assets:
            universe_code += f'        self.AddEquity("{asset}", Resolution.Daily)\n'
        return universe_code

    def _generate_strategy_logic(self, hypothesis: MarketHypothesis) -> str:
        """Generate strategy-specific logic based on hypothesis type."""

        if hypothesis.type == HypothesisType.MOMENTUM:
            return '''        # Momentum strategy logic
        for symbol in self.ActiveSecurities.Keys:
            history = self.History(symbol, 20, Resolution.Daily)
            if len(history) < 20:
                continue

            # Calculate momentum
            current_price = self.Securities[symbol].Price
            avg_price = history['close'].mean()
            momentum = (current_price - avg_price) / avg_price

            # Position sizing based on momentum and confidence
            target_weight = momentum * 0.1 * {hypothesis.confidence:.2f}
            target_weight = max(-0.1, min(0.1, target_weight))

            if abs(target_weight) > 0.01:
                self.SetHoldings(symbol, target_weight)'''

        elif hypothesis.type == HypothesisType.MEAN_REVERSION:
            return '''        # Mean reversion strategy logic
        for symbol in self.ActiveSecurities.Keys:
            history = self.History(symbol, 50, Resolution.Daily)
            if len(history) < 50:
                continue

            # Calculate z-score
            current_price = self.Securities[symbol].Price
            mean_price = history['close'].mean()
            std_price = history['close'].std()
            z_score = (current_price - mean_price) / std_price

            # Mean reversion logic with confidence adjustment
            if z_score > 2.0:
                target_weight = -0.05 * {hypothesis.confidence:.2f}
            elif z_score < -2.0:
                target_weight = 0.05 * {hypothesis.confidence:.2f}
            else:
                target_weight = 0

            if abs(target_weight) > 0.01:
                self.SetHoldings(symbol, target_weight)'''

        elif hypothesis.type == HypothesisType.ARBITRAGE:
            return '''        # Pairs trading logic
        symbols = list(self.ActiveSecurities.Keys)
        if len(symbols) >= 2:
            symbol_a, symbol_b = symbols[0], symbols[1]

            # Get price ratio
            price_a = self.Securities[symbol_a].Price
            price_b = self.Securities[symbol_b].Price
            ratio = price_a / price_b

            # Calculate historical ratio statistics
            history_a = self.History(symbol_a, 30, Resolution.Daily)['close']
            history_b = self.History(symbol_b, 30, Resolution.Daily)['close']

            if len(history_a) >= 30 and len(history_b) >= 30:
                historical_ratios = history_a / history_b
                mean_ratio = historical_ratios.mean()
                std_ratio = historical_ratios.std()

                z_score = (ratio - mean_ratio) / std_ratio

                # Pairs trading signals
                if z_score > 2.0:
                    self.SetHoldings(symbol_a, -0.05 * {hypothesis.confidence:.2f})
                    self.SetHoldings(symbol_b, 0.05 * {hypothesis.confidence:.2f})
                elif z_score < -2.0:
                    self.SetHoldings(symbol_a, 0.05 * {hypothesis.confidence:.2f})
                    self.SetHoldings(symbol_b, -0.05 * {hypothesis.confidence:.2f})'''

        else:
            return '''        # Generic strategy logic
        target_weight = 0.1 * {hypothesis.confidence:.2f} / len(self.ActiveSecurities)
        for symbol in self.ActiveSecurities.Keys:
            self.SetHoldings(symbol, target_weight)'''

    def _generate_helper_methods(self, hypothesis: MarketHypothesis) -> str:
        """Generate helper methods."""
        return '''
    def OnOrderEvent(self, orderEvent):
        """Handle order events."""
        if orderEvent.Status == OrderStatus.Filled:
            self.Log(f"Order filled: {orderEvent.Symbol} {orderEvent.FillQuantity} @ {orderEvent.FillPrice}")

    def OnEndOfAlgorithm(self):
        """Algorithm cleanup."""
        self.Log(f"Algorithm completed. Final portfolio value: {self.Portfolio.TotalPortfolioValue}")
'''


class QuantConnectExecutor:
    """Execute strategies on QuantConnect platform."""

    def __init__(self):
        self.user_id = os.getenv("QUANTCONNECT_USER_ID", "357130")
        self.api_token = os.getenv("QUANTCONNECT_API_TOKEN", "")

        if not self.api_token:
            logger.warning("QUANTCONNECT_API_TOKEN not set - will use shell commands")

    async def create_and_backtest_strategy(self, strategy: TradingStrategy) -> Dict[str, Any]:
        """Create project and run backtest using lean CLI."""

        try:
            # Create algorithm file
            algorithm_filename = f"{strategy.strategy_id}.py"

            # Write algorithm to file
            with open(algorithm_filename, 'w') as f:
                f.write(strategy.algorithm_code)

            # Use lean CLI to run backtest
            backtest_result = ally_shell_server.run_command({
                "command": ["lean", "backtest", "--verbose"],
                "workdir": ".",
                "dry_run": False,
                "timeout_seconds": 300,  # 5 minutes
                "use_ally": False
            })

            # Parse results
            if backtest_result["exit_code"] == 0:
                result = {
                    "success": True,
                    "strategy_id": strategy.strategy_id,
                    "backtest_output": backtest_result["stdout"],
                    "execution_time": backtest_result["duration_seconds"],
                    "algorithm_file": algorithm_filename
                }

                # Extract performance metrics from output if available
                output = backtest_result["stdout"]
                result.update(self._parse_backtest_output(output))

            else:
                result = {
                    "success": False,
                    "strategy_id": strategy.strategy_id,
                    "error": backtest_result["stderr"],
                    "exit_code": backtest_result["exit_code"]
                }

            # Clean up
            if os.path.exists(algorithm_filename):
                os.remove(algorithm_filename)

            return result

        except Exception as e:
            logger.error(f"Failed to execute strategy {strategy.strategy_id}: {e}")
            return {
                "success": False,
                "strategy_id": strategy.strategy_id,
                "error": str(e)
            }

    def _parse_backtest_output(self, output: str) -> Dict[str, Any]:
        """Parse backtest output for performance metrics."""

        metrics = {
            "total_return": 0.0,
            "sharpe_ratio": 0.0,
            "max_drawdown": 0.0,
            "trades_count": 0
        }

        try:
            # Basic parsing - in production would be more sophisticated
            lines = output.split('\n')
            for line in lines:
                line = line.strip().lower()

                if 'total return' in line and '%' in line:
                    # Extract percentage
                    parts = line.split('%')
                    if parts:
                        try:
                            metrics["total_return"] = float(parts[0].split()[-1]) / 100
                        except ValueError:
                            pass

                elif 'sharpe' in line:
                    # Extract Sharpe ratio
                    parts = line.split()
                    for i, part in enumerate(parts):
                        if 'sharpe' in part and i + 1 < len(parts):
                            try:
                                metrics["sharpe_ratio"] = float(parts[i + 1])
                            except ValueError:
                                pass

                elif 'drawdown' in line and '%' in line:
                    # Extract drawdown
                    parts = line.split('%')
                    if parts:
                        try:
                            metrics["max_drawdown"] = abs(float(parts[0].split()[-1])) / 100
                        except ValueError:
                            pass

        except Exception as e:
            logger.error(f"Failed to parse backtest output: {e}")

        return metrics


class AutonomousStrategyDeveloper:
    """Main autonomous strategy development system."""

    def __init__(self):
        self.hypothesis_generator = HypothesisGenerator()
        self.code_generator = StrategyCodeGenerator()
        self.executor = QuantConnectExecutor()

        # Portfolio optimization
        self.hrp_optimizer = HRPOptimizer(HRPParameters())
        self.bl_optimizer = BlackLittermanOptimizer()

        # Compliance and monitoring
        self.compliance_manager = MiFIDComplianceManager("AUTO-TRADER-001")
        self.monitor = ProductionMonitor()

        # Strategy tracking
        self.active_strategies: List[TradingStrategy] = []
        self.hypothesis_history: List[MarketHypothesis] = []
        self.performance_history: List[Dict[str, Any]] = []

    async def autonomous_development_cycle(
        self,
        market_data: Dict[str, Any],
        target_universe: List[str],
        max_strategies: int = 5
    ) -> Dict[str, Any]:
        """Run complete autonomous development cycle."""

        cycle_id = f"cycle_{int(time.time())}"
        logger.info(f"Starting autonomous development cycle {cycle_id}")

        cycle_results = {
            "cycle_id": cycle_id,
            "started_at": datetime.now(timezone.utc).isoformat(),
            "target_universe": target_universe,
            "stages": {}
        }

        try:
            # Stage 1: Generate hypotheses
            logger.info("Stage 1: Generating market hypotheses")
            hypotheses = await self.hypothesis_generator.generate_market_hypothesis(
                market_data, target_universe
            )

            cycle_results["stages"]["hypothesis_generation"] = {
                "hypotheses_count": len(hypotheses),
                "avg_confidence": sum(h.confidence for h in hypotheses) / max(1, len(hypotheses)),
                "hypothesis_types": [h.type.value for h in hypotheses]
            }

            if not hypotheses:
                cycle_results["status"] = "failed"
                cycle_results["error"] = "No hypotheses generated"
                return cycle_results

            # Stage 2: Select best hypotheses
            logger.info("Stage 2: Selecting best hypotheses")
            selected_hypotheses = self._select_best_hypotheses(hypotheses, max_strategies)

            cycle_results["stages"]["hypothesis_selection"] = {
                "selected_count": len(selected_hypotheses),
                "selection_criteria": "confidence_and_diversification"
            }

            # Stage 3: Generate strategies
            logger.info("Stage 3: Generating trading strategies")
            strategies = []
            for i, hypothesis in enumerate(selected_hypotheses):
                strategy = self._create_strategy_from_hypothesis(hypothesis, i)
                strategies.append(strategy)

            cycle_results["stages"]["strategy_generation"] = {
                "strategies_count": len(strategies),
                "strategy_ids": [s.strategy_id for s in strategies]
            }

            # Stage 4: Backtest strategies
            logger.info("Stage 4: Backtesting strategies")
            backtest_results = []

            for strategy in strategies:
                logger.info(f"Backtesting strategy {strategy.strategy_id}")
                result = await self.executor.create_and_backtest_strategy(strategy)
                backtest_results.append(result)

                # Update strategy with results
                strategy.backtest_results = result
                strategy.status = (
                    StrategyStatus.BACKTEST_COMPLETED if result.get("success")
                    else StrategyStatus.STRATEGY_REJECTED
                )

            cycle_results["stages"]["backtesting"] = {
                "completed_backtests": len(backtest_results),
                "successful_backtests": sum(1 for r in backtest_results if r.get("success")),
                "avg_execution_time": sum(
                    r.get("execution_time", 0) for r in backtest_results
                ) / max(1, len(backtest_results))
            }

            # Stage 5: Evaluate and rank
            logger.info("Stage 5: Evaluating performance")
            ranked_strategies = self._rank_strategies(strategies)

            cycle_results["stages"]["evaluation"] = {
                "ranked_strategies": len(ranked_strategies),
                "best_strategy": ranked_strategies[0].strategy_id if ranked_strategies else None,
                "performance_metrics": self._extract_performance_summary(ranked_strategies)
            }

            # Stage 6: Compliance check
            logger.info("Stage 6: Compliance validation")
            compliance_results = await self._validate_compliance(ranked_strategies)

            cycle_results["stages"]["compliance"] = compliance_results

            # Update tracking
            self.active_strategies.extend(strategies)
            self.hypothesis_history.extend(hypotheses)
            self.performance_history.append(cycle_results)

            cycle_results["status"] = "completed"
            cycle_results["completed_at"] = datetime.now(timezone.utc).isoformat()

            logger.info(f"Autonomous development cycle {cycle_id} completed successfully")
            return cycle_results

        except Exception as e:
            logger.error(f"Autonomous development cycle failed: {e}")
            cycle_results["status"] = "failed"
            cycle_results["error"] = str(e)
            cycle_results["failed_at"] = datetime.now(timezone.utc).isoformat()
            return cycle_results

    def _select_best_hypotheses(
        self,
        hypotheses: List[MarketHypothesis],
        max_count: int
    ) -> List[MarketHypothesis]:
        """Select best hypotheses based on confidence and diversification."""

        # Sort by confidence
        sorted_hypotheses = sorted(hypotheses, key=lambda h: h.confidence, reverse=True)

        # Diversify by type and agent
        selected = []
        used_types = set()
        used_agents = set()

        for hypothesis in sorted_hypotheses:
            if len(selected) >= max_count:
                break

            # Prefer diversity in hypothesis types and generating agents
            type_penalty = 0.1 if hypothesis.type in used_types else 0
            agent_penalty = 0.1 if hypothesis.generating_agent in used_agents else 0

            adjusted_confidence = hypothesis.confidence - type_penalty - agent_penalty

            if adjusted_confidence > 0.5 or len(selected) == 0:
                selected.append(hypothesis)
                used_types.add(hypothesis.type)
                used_agents.add(hypothesis.generating_agent)

        return selected

    def _create_strategy_from_hypothesis(
        self,
        hypothesis: MarketHypothesis,
        strategy_index: int
    ) -> TradingStrategy:
        """Create trading strategy from hypothesis."""

        strategy_id = f"auto_strategy_{hypothesis.hypothesis_id}_{strategy_index}"
        algorithm_code = self.code_generator.generate_algorithm_code(hypothesis)

        return TradingStrategy(
            strategy_id=strategy_id,
            name=f"Auto {hypothesis.type.value.title()} Strategy",
            hypothesis=hypothesis,
            algorithm_code=algorithm_code,
            parameters={
                "confidence": hypothesis.confidence,
                "time_horizon": hypothesis.time_horizon_days,
                "expected_return": hypothesis.expected_return
            },
            universe=hypothesis.target_assets,
            benchmark="SPY",
            start_date="2023-01-01",
            end_date="2024-01-01",
            initial_cash=100000.0,
            status=StrategyStatus.STRATEGY_DESIGNED
        )

    def _rank_strategies(self, strategies: List[TradingStrategy]) -> List[TradingStrategy]:
        """Rank strategies by performance."""

        def strategy_score(strategy: TradingStrategy) -> float:
            if not strategy.backtest_results or not strategy.backtest_results.get("success"):
                return -1.0

            results = strategy.backtest_results

            # Calculate composite score
            total_return = results.get("total_return", 0)
            sharpe_ratio = results.get("sharpe_ratio", 0)
            max_drawdown = results.get("max_drawdown", 1)

            # Penalize high drawdown
            drawdown_penalty = max_drawdown * 2

            score = (total_return * 0.4 +
                    sharpe_ratio * 0.4 +
                    strategy.hypothesis.confidence * 0.2 -
                    drawdown_penalty)

            return score

        return sorted(strategies, key=strategy_score, reverse=True)

    def _extract_performance_summary(
        self,
        strategies: List[TradingStrategy]
    ) -> Dict[str, Any]:
        """Extract performance summary from strategies."""

        successful_strategies = [
            s for s in strategies
            if s.backtest_results and s.backtest_results.get("success")
        ]

        if not successful_strategies:
            return {"successful_strategies": 0}

        returns = [s.backtest_results.get("total_return", 0) for s in successful_strategies]
        sharpe_ratios = [s.backtest_results.get("sharpe_ratio", 0) for s in successful_strategies]
        drawdowns = [s.backtest_results.get("max_drawdown", 0) for s in successful_strategies]

        return {
            "successful_strategies": len(successful_strategies),
            "avg_return": sum(returns) / len(returns),
            "best_return": max(returns),
            "avg_sharpe": sum(sharpe_ratios) / len(sharpe_ratios),
            "best_sharpe": max(sharpe_ratios),
            "avg_drawdown": sum(drawdowns) / len(drawdowns),
            "worst_drawdown": max(drawdowns)
        }

    async def _validate_compliance(
        self,
        strategies: List[TradingStrategy]
    ) -> Dict[str, Any]:
        """Validate strategies for compliance."""

        compliance_results = {
            "total_strategies": len(strategies),
            "compliant_strategies": 0,
            "compliance_issues": []
        }

        for strategy in strategies:
            try:
                # Mock trade for compliance check
                mock_trade_data = {
                    "trade_id": f"compliance_check_{strategy.strategy_id}",
                    "instrument_id": strategy.universe[0] if strategy.universe else "SPY",
                    "price": 100.0,
                    "quantity": 100,
                    "venue": "primary_exchange"
                }

                compliance_result = await self.compliance_manager.process_trade(
                    mock_trade_data, ClientCategory.PROFESSIONAL, "autonomous_system"
                )

                if compliance_result.get("compliance_status") == "compliant":
                    compliance_results["compliant_strategies"] += 1
                else:
                    compliance_results["compliance_issues"].append({
                        "strategy_id": strategy.strategy_id,
                        "issues": compliance_result.get("failed_checks", [])
                    })

            except Exception as e:
                compliance_results["compliance_issues"].append({
                    "strategy_id": strategy.strategy_id,
                    "error": str(e)
                })

        return compliance_results

    async def get_system_status(self) -> Dict[str, Any]:
        """Get comprehensive system status."""

        return {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "active_strategies": len(self.active_strategies),
            "total_hypotheses": len(self.hypothesis_history),
            "development_cycles": len(self.performance_history),
            "last_cycle": (
                self.performance_history[-1] if self.performance_history else None
            ),
            "system_health": "operational",
            "components": {
                "hypothesis_generator": "ready",
                "code_generator": "ready",
                "quantconnect_executor": "ready",
                "compliance_manager": "ready"
            }
        }


# Example usage
async def main():
    """Example autonomous strategy development."""

    # Initialize system
    developer = AutonomousStrategyDeveloper()

    # Mock market data
    market_data = {
        "spy_price": 450.0,
        "vix": 18.5,
        "risk_free_rate": 0.045,
        "market_sentiment": 0.65
    }

    # Target universe
    universe = ["AAPL", "GOOGL", "MSFT", "TSLA", "NVDA"]

    # Run autonomous development cycle
    print("ðŸ¤– Starting Autonomous Strategy Development")
    print("=" * 50)

    result = await developer.autonomous_development_cycle(
        market_data=market_data,
        target_universe=universe,
        max_strategies=3
    )

    print(f"Cycle Status: {result['status']}")
    print(f"Started: {result['started_at']}")
    if result.get('completed_at'):
        print(f"Completed: {result['completed_at']}")

    for stage, stage_data in result.get('stages', {}).items():
        print(f"\n{stage.replace('_', ' ').title()}:")
        for key, value in stage_data.items():
            print(f"  {key}: {value}")

    # Get system status
    status = await developer.get_system_status()
    print(f"\nSystem Status: {status['system_health']}")
    print(f"Total Strategies: {status['active_strategies']}")


if __name__ == "__main__":
    asyncio.run(main())